#! /usr/bin/gcl -f

; labels allow us to declare local functions within a block,
;    much the same way let allows us to declare local variables
; again, they are frequently used within functions


; ------------------ Example 1 ------------------
; sample global function, f1, with local functions f2 and f3
(defun f1 (p1)
    ; local function f2
    (labels ; the first part of labels is a block of local function definitions
             (  ; create a local function f2, that takes parameters p2 and x
                (f2 (p2 x)
                   ; the body of the function prints p2 and x and returns their sum
                   (format t "in f2, p2 is ~A~%" p2)
                   (format t "in f2, x is ~A~%" x)
                   (+ p2 x)
                )
                ; create a local function f3 that just squares p1
                (f3 () (* p1 p1))
            ) ; end of local function definitions

            ; begin the body of f1
            (format t "in f1, p1 is ~A~%" p1)
            (format t "in f1, result of calling f3 is ~A~%" (f3))
            (f2 7 3.5) ; call and return result of f2
    )
)

; ------------------ Example 2 ------------------
; this shows an appropriate use of labels:
;   the function (smallest L) returns the smallest value in list L,
;   but uses a private, tail recursive, function (tailMin L sofar)
;   to do so

(defun smallest (L)
   (labels
       ((tailMin (L1 MinSoFar)
            (cond
                ((null L1) MinSoFar)
                ((< (car L1) MinSoFar) (tailMin (cdr L1) (car L1)))
                (t (tailMin (cdr L1) MinSoFar)))))
   (cond
      ((not (listp L)) nil)
      ((null L) nil)
      (t (tailMin (cdr L) (car L))))))


; --------- sample calls for both examples -------------------

; global function calls to test it
(f1 10)
(smallest '(4 1 3 2 0 9 8 4))
